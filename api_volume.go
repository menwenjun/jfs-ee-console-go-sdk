/*
JuiceFS console API

API of the JuiceFS console (https://juicefs.com/api/v1)

API version: 0.0.1
Contact: team@juicedata.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// VolumeAPIService VolumeAPI service
type VolumeAPIService service

type ApiVolumesGetRequest struct {
	ctx context.Context
	ApiService *VolumeAPIService
	token *string
}

// Token of the region, it&#39;s once used for authentication, now deprecated. please use access key/secret key instead.
// Deprecated
func (r ApiVolumesGetRequest) Token(token string) ApiVolumesGetRequest {
	r.token = &token
	return r
}

func (r ApiVolumesGetRequest) Execute() ([]GettableVolume, *http.Response, error) {
	return r.ApiService.VolumesGetExecute(r)
}

/*
VolumesGet Get volume list

Return volume list for this region

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVolumesGetRequest
*/
func (a *VolumeAPIService) VolumesGet(ctx context.Context) ApiVolumesGetRequest {
	return ApiVolumesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []GettableVolume
func (a *VolumeAPIService) VolumesGetExecute(r ApiVolumesGetRequest) ([]GettableVolume, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GettableVolume
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VolumeAPIService.VolumesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/volumes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.token != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "token", r.token, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVolumesPostRequest struct {
	ctx context.Context
	ApiService *VolumeAPIService
	token *string
	postableVolume *PostableVolume
}

// Token of the region, it&#39;s once used for authentication, now deprecated. please use access key/secret key instead.
// Deprecated
func (r ApiVolumesPostRequest) Token(token string) ApiVolumesPostRequest {
	r.token = &token
	return r
}

func (r ApiVolumesPostRequest) PostableVolume(postableVolume PostableVolume) ApiVolumesPostRequest {
	r.postableVolume = &postableVolume
	return r
}

func (r ApiVolumesPostRequest) Execute() (*GettableVolume, *http.Response, error) {
	return r.ApiService.VolumesPostExecute(r)
}

/*
VolumesPost Method for VolumesPost

Create a volume

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVolumesPostRequest
*/
func (a *VolumeAPIService) VolumesPost(ctx context.Context) ApiVolumesPostRequest {
	return ApiVolumesPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GettableVolume
func (a *VolumeAPIService) VolumesPostExecute(r ApiVolumesPostRequest) (*GettableVolume, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GettableVolume
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VolumeAPIService.VolumesPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/volumes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.token != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "token", r.token, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.postableVolume
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVolumesVolumeIDClientsGetRequest struct {
	ctx context.Context
	ApiService *VolumeAPIService
	volumeID int32
	token *string
}

// Token of the region, it&#39;s once used for authentication, now deprecated. please use access key/secret key instead.
// Deprecated
func (r ApiVolumesVolumeIDClientsGetRequest) Token(token string) ApiVolumesVolumeIDClientsGetRequest {
	r.token = &token
	return r
}

func (r ApiVolumesVolumeIDClientsGetRequest) Execute() ([]VolumeClient, *http.Response, error) {
	return r.ApiService.VolumesVolumeIDClientsGetExecute(r)
}

/*
VolumesVolumeIDClientsGet Get mounted clients

Get mounted clients within 2 hours for this volume

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param volumeID ID of the JuiceFS volume
 @return ApiVolumesVolumeIDClientsGetRequest
*/
func (a *VolumeAPIService) VolumesVolumeIDClientsGet(ctx context.Context, volumeID int32) ApiVolumesVolumeIDClientsGetRequest {
	return ApiVolumesVolumeIDClientsGetRequest{
		ApiService: a,
		ctx: ctx,
		volumeID: volumeID,
	}
}

// Execute executes the request
//  @return []VolumeClient
func (a *VolumeAPIService) VolumesVolumeIDClientsGetExecute(r ApiVolumesVolumeIDClientsGetRequest) ([]VolumeClient, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []VolumeClient
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VolumeAPIService.VolumesVolumeIDClientsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/volumes/{volumeID}/clients"
	localVarPath = strings.Replace(localVarPath, "{"+"volumeID"+"}", url.PathEscape(parameterValueToString(r.volumeID, "volumeID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.volumeID < 1 {
		return localVarReturnValue, nil, reportError("volumeID must be greater than 1")
	}

	if r.token != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "token", r.token, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVolumesVolumeIDDeleteRequest struct {
	ctx context.Context
	ApiService *VolumeAPIService
	volumeID int32
	token *string
}

// Token of the region, it&#39;s once used for authentication, now deprecated. please use access key/secret key instead.
// Deprecated
func (r ApiVolumesVolumeIDDeleteRequest) Token(token string) ApiVolumesVolumeIDDeleteRequest {
	r.token = &token
	return r
}

func (r ApiVolumesVolumeIDDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.VolumesVolumeIDDeleteExecute(r)
}

/*
VolumesVolumeIDDelete Method for VolumesVolumeIDDelete

Delete volume by ID

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param volumeID ID of the JuiceFS volume
 @return ApiVolumesVolumeIDDeleteRequest
*/
func (a *VolumeAPIService) VolumesVolumeIDDelete(ctx context.Context, volumeID int32) ApiVolumesVolumeIDDeleteRequest {
	return ApiVolumesVolumeIDDeleteRequest{
		ApiService: a,
		ctx: ctx,
		volumeID: volumeID,
	}
}

// Execute executes the request
func (a *VolumeAPIService) VolumesVolumeIDDeleteExecute(r ApiVolumesVolumeIDDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VolumeAPIService.VolumesVolumeIDDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/volumes/{volumeID}"
	localVarPath = strings.Replace(localVarPath, "{"+"volumeID"+"}", url.PathEscape(parameterValueToString(r.volumeID, "volumeID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.volumeID < 1 {
		return nil, reportError("volumeID must be greater than 1")
	}

	if r.token != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "token", r.token, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v VolumesVolumeIDGet404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 428 {
			var v VolumesVolumeIDGet404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVolumesVolumeIDGetRequest struct {
	ctx context.Context
	ApiService *VolumeAPIService
	volumeID int32
	token *string
}

// Token of the region, it&#39;s once used for authentication, now deprecated. please use access key/secret key instead.
// Deprecated
func (r ApiVolumesVolumeIDGetRequest) Token(token string) ApiVolumesVolumeIDGetRequest {
	r.token = &token
	return r
}

func (r ApiVolumesVolumeIDGetRequest) Execute() (*GettableVolume, *http.Response, error) {
	return r.ApiService.VolumesVolumeIDGetExecute(r)
}

/*
VolumesVolumeIDGet Method for VolumesVolumeIDGet

Get volume by ID

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param volumeID ID of the JuiceFS volume
 @return ApiVolumesVolumeIDGetRequest
*/
func (a *VolumeAPIService) VolumesVolumeIDGet(ctx context.Context, volumeID int32) ApiVolumesVolumeIDGetRequest {
	return ApiVolumesVolumeIDGetRequest{
		ApiService: a,
		ctx: ctx,
		volumeID: volumeID,
	}
}

// Execute executes the request
//  @return GettableVolume
func (a *VolumeAPIService) VolumesVolumeIDGetExecute(r ApiVolumesVolumeIDGetRequest) (*GettableVolume, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GettableVolume
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VolumeAPIService.VolumesVolumeIDGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/volumes/{volumeID}"
	localVarPath = strings.Replace(localVarPath, "{"+"volumeID"+"}", url.PathEscape(parameterValueToString(r.volumeID, "volumeID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.volumeID < 1 {
		return localVarReturnValue, nil, reportError("volumeID must be greater than 1")
	}

	if r.token != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "token", r.token, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v VolumesVolumeIDGet404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVolumesVolumeIDIsReadyGetRequest struct {
	ctx context.Context
	ApiService *VolumeAPIService
	volumeID int32
	token *string
}

// Token of the region, it&#39;s once used for authentication, now deprecated. please use access key/secret key instead.
// Deprecated
func (r ApiVolumesVolumeIDIsReadyGetRequest) Token(token string) ApiVolumesVolumeIDIsReadyGetRequest {
	r.token = &token
	return r
}

func (r ApiVolumesVolumeIDIsReadyGetRequest) Execute() (*VolumesVolumeIDIsReadyGet200Response, *http.Response, error) {
	return r.ApiService.VolumesVolumeIDIsReadyGetExecute(r)
}

/*
VolumesVolumeIDIsReadyGet Volume has been ready or not

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param volumeID ID of the JuiceFS volume
 @return ApiVolumesVolumeIDIsReadyGetRequest
*/
func (a *VolumeAPIService) VolumesVolumeIDIsReadyGet(ctx context.Context, volumeID int32) ApiVolumesVolumeIDIsReadyGetRequest {
	return ApiVolumesVolumeIDIsReadyGetRequest{
		ApiService: a,
		ctx: ctx,
		volumeID: volumeID,
	}
}

// Execute executes the request
//  @return VolumesVolumeIDIsReadyGet200Response
func (a *VolumeAPIService) VolumesVolumeIDIsReadyGetExecute(r ApiVolumesVolumeIDIsReadyGetRequest) (*VolumesVolumeIDIsReadyGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VolumesVolumeIDIsReadyGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VolumeAPIService.VolumesVolumeIDIsReadyGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/volumes/{volumeID}/is_ready"
	localVarPath = strings.Replace(localVarPath, "{"+"volumeID"+"}", url.PathEscape(parameterValueToString(r.volumeID, "volumeID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.volumeID < 1 {
		return localVarReturnValue, nil, reportError("volumeID must be greater than 1")
	}

	if r.token != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "token", r.token, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVolumesVolumeIDKerberosGetRequest struct {
	ctx context.Context
	ApiService *VolumeAPIService
	volumeID int32
	token *string
}

// Token of the region, it&#39;s once used for authentication, now deprecated. please use access key/secret key instead.
// Deprecated
func (r ApiVolumesVolumeIDKerberosGetRequest) Token(token string) ApiVolumesVolumeIDKerberosGetRequest {
	r.token = &token
	return r
}

func (r ApiVolumesVolumeIDKerberosGetRequest) Execute() (*VolumeKerberos, *http.Response, error) {
	return r.ApiService.VolumesVolumeIDKerberosGetExecute(r)
}

/*
VolumesVolumeIDKerberosGet Method for VolumesVolumeIDKerberosGet

Get volume's kerberos configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param volumeID ID of the JuiceFS volume
 @return ApiVolumesVolumeIDKerberosGetRequest
*/
func (a *VolumeAPIService) VolumesVolumeIDKerberosGet(ctx context.Context, volumeID int32) ApiVolumesVolumeIDKerberosGetRequest {
	return ApiVolumesVolumeIDKerberosGetRequest{
		ApiService: a,
		ctx: ctx,
		volumeID: volumeID,
	}
}

// Execute executes the request
//  @return VolumeKerberos
func (a *VolumeAPIService) VolumesVolumeIDKerberosGetExecute(r ApiVolumesVolumeIDKerberosGetRequest) (*VolumeKerberos, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VolumeKerberos
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VolumeAPIService.VolumesVolumeIDKerberosGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/volumes/{volumeID}/kerberos"
	localVarPath = strings.Replace(localVarPath, "{"+"volumeID"+"}", url.PathEscape(parameterValueToString(r.volumeID, "volumeID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.volumeID < 1 {
		return localVarReturnValue, nil, reportError("volumeID must be greater than 1")
	}

	if r.token != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "token", r.token, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVolumesVolumeIDKerberosPatchRequest struct {
	ctx context.Context
	ApiService *VolumeAPIService
	volumeID int32
	token *string
	volumeKerberos *VolumeKerberos
}

// Token of the region, it&#39;s once used for authentication, now deprecated. please use access key/secret key instead.
// Deprecated
func (r ApiVolumesVolumeIDKerberosPatchRequest) Token(token string) ApiVolumesVolumeIDKerberosPatchRequest {
	r.token = &token
	return r
}

func (r ApiVolumesVolumeIDKerberosPatchRequest) VolumeKerberos(volumeKerberos VolumeKerberos) ApiVolumesVolumeIDKerberosPatchRequest {
	r.volumeKerberos = &volumeKerberos
	return r
}

func (r ApiVolumesVolumeIDKerberosPatchRequest) Execute() (*VolumeKerberos, *http.Response, error) {
	return r.ApiService.VolumesVolumeIDKerberosPatchExecute(r)
}

/*
VolumesVolumeIDKerberosPatch Method for VolumesVolumeIDKerberosPatch

Update volume's kerberos configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param volumeID ID of the JuiceFS volume
 @return ApiVolumesVolumeIDKerberosPatchRequest
*/
func (a *VolumeAPIService) VolumesVolumeIDKerberosPatch(ctx context.Context, volumeID int32) ApiVolumesVolumeIDKerberosPatchRequest {
	return ApiVolumesVolumeIDKerberosPatchRequest{
		ApiService: a,
		ctx: ctx,
		volumeID: volumeID,
	}
}

// Execute executes the request
//  @return VolumeKerberos
func (a *VolumeAPIService) VolumesVolumeIDKerberosPatchExecute(r ApiVolumesVolumeIDKerberosPatchRequest) (*VolumeKerberos, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VolumeKerberos
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VolumeAPIService.VolumesVolumeIDKerberosPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/volumes/{volumeID}/kerberos"
	localVarPath = strings.Replace(localVarPath, "{"+"volumeID"+"}", url.PathEscape(parameterValueToString(r.volumeID, "volumeID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.volumeID < 1 {
		return localVarReturnValue, nil, reportError("volumeID must be greater than 1")
	}

	if r.token != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "token", r.token, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.volumeKerberos
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVolumesVolumeIDListDirGetRequest struct {
	ctx context.Context
	ApiService *VolumeAPIService
	volumeID int32
	token *string
	path *string
	query *string
	page *int32
	n *int32
	childrenLimit *int32
}

// Token of the region, it&#39;s once used for authentication, now deprecated. please use access key/secret key instead.
// Deprecated
func (r ApiVolumesVolumeIDListDirGetRequest) Token(token string) ApiVolumesVolumeIDListDirGetRequest {
	r.token = &token
	return r
}

// The directory to be listed
func (r ApiVolumesVolumeIDListDirGetRequest) Path(path string) ApiVolumesVolumeIDListDirGetRequest {
	r.path = &path
	return r
}

// A keyword used to search files(case insensitive)
func (r ApiVolumesVolumeIDListDirGetRequest) Query(query string) ApiVolumesVolumeIDListDirGetRequest {
	r.query = &query
	return r
}

// Page number, starting with &#x60;0&#x60;
func (r ApiVolumesVolumeIDListDirGetRequest) Page(page int32) ApiVolumesVolumeIDListDirGetRequest {
	r.page = &page
	return r
}

// Page size
func (r ApiVolumesVolumeIDListDirGetRequest) N(n int32) ApiVolumesVolumeIDListDirGetRequest {
	r.n = &n
	return r
}

// Limit the number of children to be listed. The maximum value is 1000000 for On-premises, 100000 for SaaS.  You should be careful when setting this value to a large number, listDir may become slow or even timeout. 
func (r ApiVolumesVolumeIDListDirGetRequest) ChildrenLimit(childrenLimit int32) ApiVolumesVolumeIDListDirGetRequest {
	r.childrenLimit = &childrenLimit
	return r
}

func (r ApiVolumesVolumeIDListDirGetRequest) Execute() ([]FileInfo, *http.Response, error) {
	return r.ApiService.VolumesVolumeIDListDirGetExecute(r)
}

/*
VolumesVolumeIDListDirGet List directory

List all the files and directories within the given path. directories come first, then files and symbolic links

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param volumeID ID of the JuiceFS volume
 @return ApiVolumesVolumeIDListDirGetRequest
*/
func (a *VolumeAPIService) VolumesVolumeIDListDirGet(ctx context.Context, volumeID int32) ApiVolumesVolumeIDListDirGetRequest {
	return ApiVolumesVolumeIDListDirGetRequest{
		ApiService: a,
		ctx: ctx,
		volumeID: volumeID,
	}
}

// Execute executes the request
//  @return []FileInfo
func (a *VolumeAPIService) VolumesVolumeIDListDirGetExecute(r ApiVolumesVolumeIDListDirGetRequest) ([]FileInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []FileInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VolumeAPIService.VolumesVolumeIDListDirGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/volumes/{volumeID}/listDir"
	localVarPath = strings.Replace(localVarPath, "{"+"volumeID"+"}", url.PathEscape(parameterValueToString(r.volumeID, "volumeID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.volumeID < 1 {
		return localVarReturnValue, nil, reportError("volumeID must be greater than 1")
	}

	if r.token != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "token", r.token, "form", "")
	}
	if r.path != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "path", r.path, "form", "")
	}
	if r.query != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "query", r.query, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.n != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "n", r.n, "form", "")
	}
	if r.childrenLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "children_limit", r.childrenLimit, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v VolumesVolumeIDListDirGet400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVolumesVolumeIDMetricsGetRequest struct {
	ctx context.Context
	ApiService *VolumeAPIService
	volumeID int32
	token *string
}

// Token of the region, it&#39;s once used for authentication, now deprecated. please use access key/secret key instead.
// Deprecated
func (r ApiVolumesVolumeIDMetricsGetRequest) Token(token string) ApiVolumesVolumeIDMetricsGetRequest {
	r.token = &token
	return r
}

func (r ApiVolumesVolumeIDMetricsGetRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.VolumesVolumeIDMetricsGetExecute(r)
}

/*
VolumesVolumeIDMetricsGet Get volume metrics

Return prometheus format volume metrics

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param volumeID ID of the JuiceFS volume
 @return ApiVolumesVolumeIDMetricsGetRequest
*/
func (a *VolumeAPIService) VolumesVolumeIDMetricsGet(ctx context.Context, volumeID int32) ApiVolumesVolumeIDMetricsGetRequest {
	return ApiVolumesVolumeIDMetricsGetRequest{
		ApiService: a,
		ctx: ctx,
		volumeID: volumeID,
	}
}

// Execute executes the request
//  @return string
func (a *VolumeAPIService) VolumesVolumeIDMetricsGetExecute(r ApiVolumesVolumeIDMetricsGetRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VolumeAPIService.VolumesVolumeIDMetricsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/volumes/{volumeID}/metrics"
	localVarPath = strings.Replace(localVarPath, "{"+"volumeID"+"}", url.PathEscape(parameterValueToString(r.volumeID, "volumeID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.volumeID < 1 {
		return localVarReturnValue, nil, reportError("volumeID must be greater than 1")
	}

	if r.token != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "token", r.token, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVolumesVolumeIDMirrorsGetRequest struct {
	ctx context.Context
	ApiService *VolumeAPIService
	volumeID int32
}

func (r ApiVolumesVolumeIDMirrorsGetRequest) Execute() (*MirrorVolume, *http.Response, error) {
	return r.ApiService.VolumesVolumeIDMirrorsGetExecute(r)
}

/*
VolumesVolumeIDMirrorsGet Method for VolumesVolumeIDMirrorsGet

Get mirror volumes

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param volumeID ID of the JuiceFS volume
 @return ApiVolumesVolumeIDMirrorsGetRequest
*/
func (a *VolumeAPIService) VolumesVolumeIDMirrorsGet(ctx context.Context, volumeID int32) ApiVolumesVolumeIDMirrorsGetRequest {
	return ApiVolumesVolumeIDMirrorsGetRequest{
		ApiService: a,
		ctx: ctx,
		volumeID: volumeID,
	}
}

// Execute executes the request
//  @return MirrorVolume
func (a *VolumeAPIService) VolumesVolumeIDMirrorsGetExecute(r ApiVolumesVolumeIDMirrorsGetRequest) (*MirrorVolume, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MirrorVolume
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VolumeAPIService.VolumesVolumeIDMirrorsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/volumes/{volumeID}/mirrors"
	localVarPath = strings.Replace(localVarPath, "{"+"volumeID"+"}", url.PathEscape(parameterValueToString(r.volumeID, "volumeID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.volumeID < 1 {
		return localVarReturnValue, nil, reportError("volumeID must be greater than 1")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVolumesVolumeIDMirrorsPostRequest struct {
	ctx context.Context
	ApiService *VolumeAPIService
	volumeID int32
	createMirrorVolume *CreateMirrorVolume
}

func (r ApiVolumesVolumeIDMirrorsPostRequest) CreateMirrorVolume(createMirrorVolume CreateMirrorVolume) ApiVolumesVolumeIDMirrorsPostRequest {
	r.createMirrorVolume = &createMirrorVolume
	return r
}

func (r ApiVolumesVolumeIDMirrorsPostRequest) Execute() (*CreateMirrorVolume, *http.Response, error) {
	return r.ApiService.VolumesVolumeIDMirrorsPostExecute(r)
}

/*
VolumesVolumeIDMirrorsPost Method for VolumesVolumeIDMirrorsPost

Create mirror volume

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param volumeID ID of the JuiceFS volume
 @return ApiVolumesVolumeIDMirrorsPostRequest
*/
func (a *VolumeAPIService) VolumesVolumeIDMirrorsPost(ctx context.Context, volumeID int32) ApiVolumesVolumeIDMirrorsPostRequest {
	return ApiVolumesVolumeIDMirrorsPostRequest{
		ApiService: a,
		ctx: ctx,
		volumeID: volumeID,
	}
}

// Execute executes the request
//  @return CreateMirrorVolume
func (a *VolumeAPIService) VolumesVolumeIDMirrorsPostExecute(r ApiVolumesVolumeIDMirrorsPostRequest) (*CreateMirrorVolume, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateMirrorVolume
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VolumeAPIService.VolumesVolumeIDMirrorsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/volumes/{volumeID}/mirrors"
	localVarPath = strings.Replace(localVarPath, "{"+"volumeID"+"}", url.PathEscape(parameterValueToString(r.volumeID, "volumeID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.volumeID < 1 {
		return localVarReturnValue, nil, reportError("volumeID must be greater than 1")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createMirrorVolume
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVolumesVolumeIDRangerGetRequest struct {
	ctx context.Context
	ApiService *VolumeAPIService
	volumeID int32
	token *string
}

// Token of the region, it&#39;s once used for authentication, now deprecated. please use access key/secret key instead.
// Deprecated
func (r ApiVolumesVolumeIDRangerGetRequest) Token(token string) ApiVolumesVolumeIDRangerGetRequest {
	r.token = &token
	return r
}

func (r ApiVolumesVolumeIDRangerGetRequest) Execute() (*VolumeRanger, *http.Response, error) {
	return r.ApiService.VolumesVolumeIDRangerGetExecute(r)
}

/*
VolumesVolumeIDRangerGet Method for VolumesVolumeIDRangerGet

Get volume's ranger configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param volumeID ID of the JuiceFS volume
 @return ApiVolumesVolumeIDRangerGetRequest
*/
func (a *VolumeAPIService) VolumesVolumeIDRangerGet(ctx context.Context, volumeID int32) ApiVolumesVolumeIDRangerGetRequest {
	return ApiVolumesVolumeIDRangerGetRequest{
		ApiService: a,
		ctx: ctx,
		volumeID: volumeID,
	}
}

// Execute executes the request
//  @return VolumeRanger
func (a *VolumeAPIService) VolumesVolumeIDRangerGetExecute(r ApiVolumesVolumeIDRangerGetRequest) (*VolumeRanger, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VolumeRanger
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VolumeAPIService.VolumesVolumeIDRangerGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/volumes/{volumeID}/ranger"
	localVarPath = strings.Replace(localVarPath, "{"+"volumeID"+"}", url.PathEscape(parameterValueToString(r.volumeID, "volumeID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.volumeID < 1 {
		return localVarReturnValue, nil, reportError("volumeID must be greater than 1")
	}

	if r.token != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "token", r.token, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVolumesVolumeIDRangerPatchRequest struct {
	ctx context.Context
	ApiService *VolumeAPIService
	volumeID int32
	token *string
	volumeRanger *VolumeRanger
}

// Token of the region, it&#39;s once used for authentication, now deprecated. please use access key/secret key instead.
// Deprecated
func (r ApiVolumesVolumeIDRangerPatchRequest) Token(token string) ApiVolumesVolumeIDRangerPatchRequest {
	r.token = &token
	return r
}

func (r ApiVolumesVolumeIDRangerPatchRequest) VolumeRanger(volumeRanger VolumeRanger) ApiVolumesVolumeIDRangerPatchRequest {
	r.volumeRanger = &volumeRanger
	return r
}

func (r ApiVolumesVolumeIDRangerPatchRequest) Execute() (*VolumeRanger, *http.Response, error) {
	return r.ApiService.VolumesVolumeIDRangerPatchExecute(r)
}

/*
VolumesVolumeIDRangerPatch Method for VolumesVolumeIDRangerPatch

Update volume's ranger configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param volumeID ID of the JuiceFS volume
 @return ApiVolumesVolumeIDRangerPatchRequest
*/
func (a *VolumeAPIService) VolumesVolumeIDRangerPatch(ctx context.Context, volumeID int32) ApiVolumesVolumeIDRangerPatchRequest {
	return ApiVolumesVolumeIDRangerPatchRequest{
		ApiService: a,
		ctx: ctx,
		volumeID: volumeID,
	}
}

// Execute executes the request
//  @return VolumeRanger
func (a *VolumeAPIService) VolumesVolumeIDRangerPatchExecute(r ApiVolumesVolumeIDRangerPatchRequest) (*VolumeRanger, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VolumeRanger
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VolumeAPIService.VolumesVolumeIDRangerPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/volumes/{volumeID}/ranger"
	localVarPath = strings.Replace(localVarPath, "{"+"volumeID"+"}", url.PathEscape(parameterValueToString(r.volumeID, "volumeID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.volumeID < 1 {
		return localVarReturnValue, nil, reportError("volumeID must be greater than 1")
	}

	if r.token != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "token", r.token, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.volumeRanger
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVolumesVolumeIDSettingGetRequest struct {
	ctx context.Context
	ApiService *VolumeAPIService
	volumeID int32
	token *string
}

// Token of the region, it&#39;s once used for authentication, now deprecated. please use access key/secret key instead.
// Deprecated
func (r ApiVolumesVolumeIDSettingGetRequest) Token(token string) ApiVolumesVolumeIDSettingGetRequest {
	r.token = &token
	return r
}

func (r ApiVolumesVolumeIDSettingGetRequest) Execute() (*TrashTime, *http.Response, error) {
	return r.ApiService.VolumesVolumeIDSettingGetExecute(r)
}

/*
VolumesVolumeIDSettingGet Method for VolumesVolumeIDSettingGet

Get volume trashtime (days)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param volumeID ID of the JuiceFS volume
 @return ApiVolumesVolumeIDSettingGetRequest
*/
func (a *VolumeAPIService) VolumesVolumeIDSettingGet(ctx context.Context, volumeID int32) ApiVolumesVolumeIDSettingGetRequest {
	return ApiVolumesVolumeIDSettingGetRequest{
		ApiService: a,
		ctx: ctx,
		volumeID: volumeID,
	}
}

// Execute executes the request
//  @return TrashTime
func (a *VolumeAPIService) VolumesVolumeIDSettingGetExecute(r ApiVolumesVolumeIDSettingGetRequest) (*TrashTime, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TrashTime
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VolumeAPIService.VolumesVolumeIDSettingGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/volumes/{volumeID}/setting"
	localVarPath = strings.Replace(localVarPath, "{"+"volumeID"+"}", url.PathEscape(parameterValueToString(r.volumeID, "volumeID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.volumeID < 1 {
		return localVarReturnValue, nil, reportError("volumeID must be greater than 1")
	}

	if r.token != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "token", r.token, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVolumesVolumeIDSettingPostRequest struct {
	ctx context.Context
	ApiService *VolumeAPIService
	volumeID int32
	token *string
	trashTime *TrashTime
}

// Token of the region, it&#39;s once used for authentication, now deprecated. please use access key/secret key instead.
// Deprecated
func (r ApiVolumesVolumeIDSettingPostRequest) Token(token string) ApiVolumesVolumeIDSettingPostRequest {
	r.token = &token
	return r
}

func (r ApiVolumesVolumeIDSettingPostRequest) TrashTime(trashTime TrashTime) ApiVolumesVolumeIDSettingPostRequest {
	r.trashTime = &trashTime
	return r
}

func (r ApiVolumesVolumeIDSettingPostRequest) Execute() (*TrashTime, *http.Response, error) {
	return r.ApiService.VolumesVolumeIDSettingPostExecute(r)
}

/*
VolumesVolumeIDSettingPost Method for VolumesVolumeIDSettingPost

Set volume trashtime (days)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param volumeID ID of the JuiceFS volume
 @return ApiVolumesVolumeIDSettingPostRequest
*/
func (a *VolumeAPIService) VolumesVolumeIDSettingPost(ctx context.Context, volumeID int32) ApiVolumesVolumeIDSettingPostRequest {
	return ApiVolumesVolumeIDSettingPostRequest{
		ApiService: a,
		ctx: ctx,
		volumeID: volumeID,
	}
}

// Execute executes the request
//  @return TrashTime
func (a *VolumeAPIService) VolumesVolumeIDSettingPostExecute(r ApiVolumesVolumeIDSettingPostRequest) (*TrashTime, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TrashTime
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VolumeAPIService.VolumesVolumeIDSettingPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/volumes/{volumeID}/setting"
	localVarPath = strings.Replace(localVarPath, "{"+"volumeID"+"}", url.PathEscape(parameterValueToString(r.volumeID, "volumeID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.volumeID < 1 {
		return localVarReturnValue, nil, reportError("volumeID must be greater than 1")
	}

	if r.token != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "token", r.token, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.trashTime
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
